#!/usr/bin/env node

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import path from "path";
import fs from "fs/promises";
import { compressImage, SUPPORTED_FORMATS } from "./compressImage.js";
import { compressFolder } from "./compressFolder.js";
import { getImageInfo } from "./getImageInfo.js";
import uploadToOSS from "./uploadToOSS.js";
import uploadFolderToOSS from "./uploadFolderToOSS.js";

// åˆ›å»ºMCPæœåŠ¡å™¨å®ä¾‹
const server = new Server(
  {
    name: "mcp-img-compress-oss",
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// å·¥å…·åˆ—è¡¨
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "compress_image",
        description:
          "å‹ç¼©å•ä¸ªå›¾ç‰‡æ–‡ä»¶ï¼Œæ”¯æŒJPEGã€PNGã€WebPã€AVIFç­‰æ ¼å¼ã€‚âš ï¸ é‡è¦ï¼šè¯·ä½¿ç”¨ç»å¯¹è·¯å¾„æŒ‡å®šå›¾ç‰‡æ–‡ä»¶ä½ç½®ã€‚",
        inputSchema: {
          type: "object",
          properties: {
            inputPath: {
              type: "string",
              description:
                "è¦å‹ç¼©çš„å›¾ç‰‡æ–‡ä»¶è·¯å¾„ï¼ˆå¿…é¡»ä½¿ç”¨ç»å¯¹è·¯å¾„ï¼Œå¦‚ï¼š/Users/username/Desktop/photo.jpgï¼‰",
            },
            outputPath: {
              type: "string",
              description:
                "å‹ç¼©åçš„è¾“å‡ºæ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸ºåŸæ–‡ä»¶å_compressedï¼Œå»ºè®®ä½¿ç”¨ç»å¯¹è·¯å¾„ï¼‰",
            },
            quality: {
              type: "number",
              description: "å‹ç¼©è´¨é‡ (1-100)ï¼Œé»˜è®¤95ï¼ˆæ— æŸæˆ–è¿‘æ— æŸï¼‰",
              minimum: 1,
              maximum: 100,
              default: 95,
            },
            format: {
              type: "string",
              description: "è¾“å‡ºæ ¼å¼ï¼ˆå¯é€‰ï¼‰ï¼šjpeg, png, webp, avif",
              enum: ["jpeg", "png", "webp", "avif"],
            },
            keepMetadata: {
              type: "boolean",
              description: "æ˜¯å¦ä¿ç•™å›¾ç‰‡å…ƒæ•°æ®ï¼Œé»˜è®¤ false",
              default: false,
            },
          },
          required: ["inputPath"],
        },
      },
      {
        name: "compress_folder",
        description:
          "æ‰¹é‡å‹ç¼©æ–‡ä»¶å¤¹ä¸­çš„æ‰€æœ‰å›¾ç‰‡æ–‡ä»¶ã€‚âš ï¸ é‡è¦ï¼šè¯·ä½¿ç”¨ç»å¯¹è·¯å¾„æŒ‡å®šæ–‡ä»¶å¤¹ä½ç½®ã€‚",
        inputSchema: {
          type: "object",
          properties: {
            inputFolder: {
              type: "string",
              description:
                "è¦å‹ç¼©çš„å›¾ç‰‡æ–‡ä»¶å¤¹è·¯å¾„ï¼ˆå¿…é¡»ä½¿ç”¨ç»å¯¹è·¯å¾„ï¼Œå¦‚ï¼š/Users/username/Pictures/ï¼‰",
            },
            outputFolder: {
              type: "string",
              description:
                "å‹ç¼©åçš„è¾“å‡ºæ–‡ä»¶å¤¹è·¯å¾„ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸ºåŸæ–‡ä»¶å¤¹_compressedï¼Œå»ºè®®ä½¿ç”¨ç»å¯¹è·¯å¾„ï¼‰",
            },
            quality: {
              type: "number",
              description: "å‹ç¼©è´¨é‡ (1-100)ï¼Œé»˜è®¤95ï¼ˆæ— æŸæˆ–è¿‘æ— æŸï¼‰",
              minimum: 1,
              maximum: 100,
              default: 95,
            },
            format: {
              type: "string",
              description: "ç»Ÿä¸€è¾“å‡ºæ ¼å¼ï¼ˆå¯é€‰ï¼‰ï¼šjpeg, png, webp, avif",
              enum: ["jpeg", "png", "webp", "avif"],
            },
            recursive: {
              type: "boolean",
              description: "æ˜¯å¦é€’å½’å¤„ç†å­æ–‡ä»¶å¤¹ï¼Œé»˜è®¤true",
              default: true,
            },
          },
          required: ["inputFolder"],
        },
      },
      {
        name: "get_image_info",
        description:
          "è·å–å›¾ç‰‡æ–‡ä»¶çš„è¯¦ç»†ä¿¡æ¯ï¼ˆå°ºå¯¸ã€æ ¼å¼ã€å¤§å°ç­‰ï¼‰ã€‚âš ï¸ é‡è¦ï¼šè¯·ä½¿ç”¨ç»å¯¹è·¯å¾„æŒ‡å®šå›¾ç‰‡æ–‡ä»¶ä½ç½®ã€‚",
        inputSchema: {
          type: "object",
          properties: {
            imagePath: {
              type: "string",
              description:
                "å›¾ç‰‡æ–‡ä»¶è·¯å¾„ï¼ˆå¿…é¡»ä½¿ç”¨ç»å¯¹è·¯å¾„ï¼Œå¦‚ï¼š/Users/username/Desktop/photo.jpgï¼‰",
            },
          },
          required: ["imagePath"],
        },
      },
      {
        name: "upload_to_oss",
        description:
          "å°†å›¾ç‰‡ä¸Šä¼ åˆ°é˜¿é‡Œäº‘OSSå¹¶è·å–è®¿é—®é“¾æ¥ã€‚âš ï¸ é‡è¦ï¼šè¯·ä½¿ç”¨ç»å¯¹è·¯å¾„æŒ‡å®šå›¾ç‰‡æ–‡ä»¶ä½ç½®ã€‚",
        inputSchema: {
          type: "object",
          properties: {
            imagePath: {
              type: "string",
              description:
                "å›¾ç‰‡æ–‡ä»¶è·¯å¾„ï¼ˆå¿…é¡»ä½¿ç”¨ç»å¯¹è·¯å¾„ï¼Œå¦‚ï¼š/Users/username/Desktop/photo.jpgï¼‰",
            },
            endpoint: {
              type: "string",
              description: "OSSç«¯ç‚¹ï¼ˆå¿…éœ€ï¼‰",
            },
            accessKeyId: {
              type: "string",
              description: "è®¿é—®å¯†é’¥IDï¼ˆå¿…éœ€ï¼‰",
            },
            accessKeySecret: {
              type: "string",
              description: "è®¿é—®å¯†é’¥å¯†ç ï¼ˆå¿…éœ€ï¼‰",
            },
            bucket: {
              type: "string",
              description: "OSSå­˜å‚¨æ¡¶åç§°ï¼ˆå¿…éœ€ï¼‰",
            },
            region: {
              type: "string",
              description: "OSSåŒºåŸŸï¼ˆå¿…éœ€ï¼‰",
            },
            ossPath: {
              type: "string",
              description: "OSSä¸­çš„å­˜å‚¨è·¯å¾„å‰ç¼€ï¼Œé»˜è®¤ä¸ºç©º",
              default: "",
            },
            customFilename: {
              type: "string",
              description: "è‡ªå®šä¹‰æ–‡ä»¶åï¼ˆä¸åŒ…å«æ‰©å±•åï¼‰ï¼Œé»˜è®¤ä½¿ç”¨åŸæ–‡ä»¶å",
            },
          },
          required: ["imagePath", "endpoint", "accessKeyId", "accessKeySecret", "bucket", "region"],
        },
      },
      {
        name: "upload_folder_to_oss",
        description:
          "æ‰¹é‡ä¸Šä¼ æ–‡ä»¶å¤¹ä¸­çš„å›¾ç‰‡åˆ°é˜¿é‡Œäº‘OSSã€‚âš ï¸ é‡è¦ï¼šè¯·ä½¿ç”¨ç»å¯¹è·¯å¾„æŒ‡å®šæ–‡ä»¶å¤¹ä½ç½®ã€‚",
        inputSchema: {
          type: "object",
          properties: {
            inputFolder: {
              type: "string",
              description:
                "å›¾ç‰‡æ–‡ä»¶å¤¹è·¯å¾„ï¼ˆå¿…é¡»ä½¿ç”¨ç»å¯¹è·¯å¾„ï¼Œå¦‚ï¼š/Users/username/Pictures/ï¼‰",
            },
            recursive: {
              type: "boolean",
              description: "æ˜¯å¦é€’å½’å¤„ç†å­æ–‡ä»¶å¤¹ï¼Œé»˜è®¤true",
              default: true,
            },
            endpoint: {
              type: "string",
              description: "OSSç«¯ç‚¹ï¼ˆå¿…éœ€ï¼‰",
            },
            accessKeyId: {
              type: "string",
              description: "è®¿é—®å¯†é’¥IDï¼ˆå¿…éœ€ï¼‰",
            },
            accessKeySecret: {
              type: "string",
              description: "è®¿é—®å¯†é’¥å¯†ç ï¼ˆå¿…éœ€ï¼‰",
            },
            bucket: {
              type: "string",
              description: "OSSå­˜å‚¨æ¡¶åç§°ï¼ˆå¿…éœ€ï¼‰",
            },
            region: {
              type: "string",
              description: "OSSåŒºåŸŸï¼ˆå¿…éœ€ï¼‰",
            },
            ossPath: {
              type: "string",
              description: "OSSä¸­çš„å­˜å‚¨è·¯å¾„å‰ç¼€ï¼Œé»˜è®¤ä¸ºç©º",
              default: "",
            },
          },
          required: ["inputFolder", "endpoint", "accessKeyId", "accessKeySecret", "bucket", "region"],
        },
      },
    ],
  };
});

// å·¥å…·è°ƒç”¨åˆ†å‘
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    switch (name) {
      case "compress_image": {
        const {
          inputPath,
          outputPath,
          quality = 95,
          format,
          keepMetadata = true,
        } = args;

        // æ£€æŸ¥è¾“å…¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        try {
          await fs.access(inputPath);
        } catch {
          throw new Error(`è¾“å…¥æ–‡ä»¶ä¸å­˜åœ¨: ${inputPath}`);
        }

        // æ£€æŸ¥æ–‡ä»¶æ ¼å¼æ˜¯å¦æ”¯æŒ
        const ext = path.extname(inputPath).toLowerCase();
        if (!SUPPORTED_FORMATS.includes(ext)) {
          throw new Error(
            `ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: ${ext}. æ”¯æŒçš„æ ¼å¼: ${SUPPORTED_FORMATS.join(
              ", "
            )}`
          );
        }

        // ç”Ÿæˆè¾“å‡ºè·¯å¾„
        let finalOutputPath = outputPath;
        if (!finalOutputPath) {
          const dir = path.dirname(inputPath);
          const name = path.basename(inputPath, ext);
          const outputExt = format ? `.${format}` : ext;
          finalOutputPath = path.join(dir, `${name}_compressed${outputExt}`);
        }

        // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
        const outputDir = path.dirname(finalOutputPath);
        await fs.mkdir(outputDir, { recursive: true });

        const result = await compressImage(inputPath, finalOutputPath, {
          quality,
          format,
          keepMetadata,
          progressive: true,
        });

        if (result.success) {
          return {
            content: [
              {
                type: "text",
                text: `âœ… å›¾ç‰‡å‹ç¼©æˆåŠŸï¼\n\nğŸ“ è¾“å…¥æ–‡ä»¶: ${result.inputPath}\nğŸ“ è¾“å‡ºæ–‡ä»¶: ${result.outputPath}\nğŸ“Š åŸå§‹å¤§å°: ${result.originalSize}\nğŸ“Š å‹ç¼©åå¤§å°: ${result.compressedSize}\nğŸ“ˆ å‹ç¼©ç‡: ${result.compressionRatio}\nğŸ–¼ï¸  æ ¼å¼: ${result.format}\nğŸ“ å°ºå¯¸: ${result.dimensions}`,
              },
            ],
          };
        } else {
          throw new Error(result.error);
        }
      }

      case "compress_folder": {
        const {
          inputFolder,
          outputFolder,
          quality = 95,
          format,
          recursive = true,
        } = args;

        const result = await compressFolder(inputFolder, outputFolder, {
          quality,
          format,
          recursive,
        });

        if (result.success) {
          return {
            content: [
              {
                type: "text",
                text: result.message,
              },
            ],
          };
        } else {
          throw new Error(result.message);
        }
      }

      case "get_image_info": {
        const { imagePath } = args;
        try {
          const info = await getImageInfo(imagePath);
          return {
            content: [
              {
                type: "text",
                text: `ğŸ“· å›¾ç‰‡ä¿¡æ¯\n\nğŸ“ æ–‡ä»¶è·¯å¾„: ${
                  info.filePath
                }\nğŸ“Š æ–‡ä»¶å¤§å°: ${info.fileSize}\nğŸ–¼ï¸  æ ¼å¼: ${
                  info.format
                }\nğŸ“ å°ºå¯¸: ${info.dimensions}\nğŸ¨ é¢œè‰²é€šé“: ${
                  info.channels
                }\nğŸ“ åƒç´ å¯†åº¦: ${info.density} DPI\nğŸ”„ æ˜¯å¦æœ‰é€æ˜é€šé“: ${
                  info.hasAlpha ? "æ˜¯" : "å¦"
                }\nğŸ“± é¢œè‰²ç©ºé—´: ${info.colorSpace}`,
              },
            ],
          };
        } catch (error) {
          throw new Error(error.message);
        }
      }

      case "upload_to_oss": {
        const {
          imagePath,
          endpoint,
          accessKeyId,
          accessKeySecret,
          bucket,
          region,
          ossPath,
          customFilename,
        } = args;

        try {
          const result = await uploadToOSS({
            imagePath,
            endpoint,
            accessKeyId,
            accessKeySecret,
            bucket,
            region,
            ossPath,
            customFilename,
          });

          if (result.success) {
            return {
              content: [
                {
                  type: "text",
                  text: `âœ… å›¾ç‰‡ä¸Šä¼ æˆåŠŸï¼\n\nğŸ“ æœ¬åœ°æ–‡ä»¶: ${result.originalPath}\nğŸ”— è®¿é—®é“¾æ¥: ${result.url}\nğŸ“Š æ–‡ä»¶å¤§å°: ${result.size} å­—èŠ‚\nğŸ–¼ï¸  æ ¼å¼: ${result.format}\nğŸ“ OSSè·¯å¾„: ${result.ossPath}`,
                },
              ],
            };
          } else {
            throw new Error(result.error);
          }
        } catch (error) {
          throw new Error(`ä¸Šä¼ å¤±è´¥: ${error.message}`);
        }
      }

      case "upload_folder_to_oss": {
        const {
          inputFolder,
          recursive = true,
          endpoint,
          accessKeyId,
          accessKeySecret,
          bucket,
          region,
          ossPath,
        } = args;

        try {
          const result = await uploadFolderToOSS({
            inputFolder,
            recursive,
            endpoint,
            accessKeyId,
            accessKeySecret,
            bucket,
            region,
            ossPath,
          });

          if (result.success) {
            // ç”Ÿæˆä¸Šä¼ ç»“æœæ‘˜è¦
            const successList = result.results.filter((r) => r.success);
            const failedList = result.results.filter((r) => !r.success);
            
            let summaryText = `âœ… æ–‡ä»¶å¤¹ä¸Šä¼ å®Œæˆ\n\nğŸ“ æ–‡ä»¶å¤¹: ${inputFolder}\nğŸ“Š æ€»æ–‡ä»¶æ•°: ${result.totalFiles}\nâœ… ä¸Šä¼ æˆåŠŸ: ${result.uploadedFiles}\nâŒ ä¸Šä¼ å¤±è´¥: ${result.failedFiles}\n\n`;
            
            if (successList.length > 0) {
              summaryText += `æˆåŠŸä¸Šä¼ çš„æ–‡ä»¶:\n`;
              successList.slice(0, 10).forEach((item, index) => {
                summaryText += `${index + 1}. ${path.basename(item.originalPath)} -> ${item.url}\n`;
              });
              
              if (successList.length > 10) {
                summaryText += `...ç­‰å…± ${successList.length} ä¸ªæ–‡ä»¶\n`;
              }
            }
            
            if (failedList.length > 0) {
              summaryText += `\nä¸Šä¼ å¤±è´¥çš„æ–‡ä»¶:\n`;
              failedList.slice(0, 5).forEach((item, index) => {
                summaryText += `${index + 1}. ${path.basename(item.originalPath)}: ${item.error}\n`;
              });
              
              if (failedList.length > 5) {
                summaryText += `...ç­‰å…± ${failedList.length} ä¸ªæ–‡ä»¶\n`;
              }
            }
            
            return {
              content: [
                {
                  type: "text",
                  text: summaryText,
                },
              ],
            };
          } else {
            throw new Error(result.message || "ä¸Šä¼ å¤±è´¥");
          }
        } catch (error) {
          throw new Error(`æ‰¹é‡ä¸Šä¼ å¤±è´¥: ${error.message}`);
        }
      }

      default:
        throw new Error(`æœªçŸ¥çš„å·¥å…·: ${name}`);
    }
  } catch (error) {
    return {
      content: [
        {
          type: "text",
          text: `âŒ é”™è¯¯: ${error.message}`,
        },
      ],
      isError: true,
    };
  }
});

// å¯åŠ¨æœåŠ¡å™¨
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("å›¾ç‰‡å¤„ç†ä¸OSSä¸Šä¼ MCPæœåŠ¡å™¨å·²å¯åŠ¨");
}

main().catch((error) => {
  console.error("æœåŠ¡å™¨å¯åŠ¨å¤±è´¥:", error);
  process.exit(1);
});
